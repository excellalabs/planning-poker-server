
import { PubSub } from 'graphql-subscriptions'
import { BasePubSub } from '../pubsub'

interface PublicPubSub {
  publishData (event: string, data: any): void
  makeSubscription (event: string, original?: any): AsyncIterator<any>
}

describe('BasePubSub', () => {
  describe('publishData', () => {
    let pubsub: PubSub
    let instance: PublicPubSub

    beforeEach(() => {
      pubsub = new PubSub()
      instance = new BasePubSub(pubsub) as any
    })

    it('should call this.core.publish once', () => {
      const event = 'some event'
      const data = {
        some: 'data',
      }

      instance.publishData(event, data)

      expect(pubsub.publish).toHaveBeenCalledTimes(1)
      expect(pubsub.publish).toHaveBeenCalledWith(event, data)
    })
  })

  describe('makeSubscription', () => {
    let pubsub: PubSub
    let asyncIterator: jest.Mock
    let instance: PublicPubSub

    beforeEach(() => {
      pubsub = new PubSub()
      instance = new BasePubSub(pubsub) as any
      asyncIterator = pubsub.asyncIterator as jest.Mock
    })

    it('should call this.core.asyncIterator once', () => {
      const event = 'my event'

      instance.makeSubscription(event)

      expect(pubsub.asyncIterator).toHaveBeenCalledTimes(1)
      expect(pubsub.asyncIterator).toHaveBeenCalledWith(event)
    })

    it('should return the result of this.core.asyncIterator if no original value is passed in', () => {
      const iterator = {
        some: 'iterator',
      }
      asyncIterator.mockReturnValue(iterator)

      const result = instance.makeSubscription('event')

      expect(result).toBe(iterator)
    })

    it('should yield the object passed in and then the values generated by this.core.asyncIterator', async () => {
      const iteratorValue = { some: 'value' }
      const iterator = (async function* () { yield iteratorValue })()
      const baseValue = { some: 'other value' }
      asyncIterator.mockReturnValue(iterator)

      const result = instance.makeSubscription('event', baseValue)

      const first = (await result.next()).value
      const second = (await result.next()).value

      expect(first).toBe(baseValue)
      expect(second).toBe(iteratorValue)
    })
  })
})
